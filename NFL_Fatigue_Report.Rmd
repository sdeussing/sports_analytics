---
title: "NFL Fatigue Analysis in Defensive Linemen"
author: "Sarah Deussing & Imogen Meers"
date: "2024-11-11"
output:
  pdf_document: default
  html_document: default
---

## Introduction
Our analysis will study fatigue in defensive linemen using their speed and acceleration and its effect on production and "mistakes". Our motivation for pursuing this problem is our interest in the performance of defensive linemen as at the end of the game, they often make pivotal plays both good and bad that can change the game script. We wanted to see if fatigue is a factor for certain players.

We will be calculating a player load and analyze the defensive player's effectiveness. To do so, we will combine this movement data with play outcome data - if the player sacked the quarterback, had a solo tackle, etc. The outcome of our analysis will be to evaluate players based on "mistakes", positive plays and player fatigue, by including game-time variables, and demographic variables such as height, weight, and age. We will be using K-Mean Clustering methods to group similar defensive linemen based on these variables. Finally, we will advise teams/coaches of the most fatigue-resistant and productive linemen that are currently free agents and provide use cases for our model to track player fatigue and lessen the number of penalties.

#### Data Overview
The dataset is a part of the NFL Big Data Bowl 2025, and it is taken from:
https://www.kaggle.com/competitions/nfl-big-data-bowl-2025/data. The data contains information from the 2022 NFL season. We are going to use four main parts of the dataset: player_play, players, plays, and the tracking data for each week.

The player_play data contains information about the action of the play, including its outcome or any penalties. Each row corresponds to one player's individual actions for each play within a game.

The players data contains information about each player, including position, height, weight, and college. We will use this data to filter to only defensive linemen within all data sets.

The plays data contains information about the quarter, time, and contents of each play.

The tracking data has the x-coordinate, y-coordinate, direction, orientation, speed, and acceleration for each player involved in each play in a game. We will use this movement data to calculate player fatigue and load. This tracking data is available for all 9 weeks of the season and is captured on a frame-by-frame level.

The datasets can be joined on: gameId, playId, and nflId, and we will filter to only defensive linemen for our analysis.

## Related Work & Research

There has been published research on long-term fatigue and "burnout" in NFL players over the course of their careers, which focuses on long-term health and physiological effects. There has also been research on game day fatigue in European Football to determine limitations on performance based on fatigue, in order to create suitable, enhancing interventions (Alghannam). However, there is no player specific or NFL game day based fatigue analysis, which is what will set our project apart.

We wanted to find a measure of fatigue that was derived from tracking data. From an study on _Monitoring Fatigue During Intermittent Exercise With Accelerometer-Derived Metrics_ and Catapult's own description of Player Load, we found this idea of "Dynamic Load", that is a sum of triaxial acceleration across a set time period. We do not have acceleration in three plains but we do have an acceleration in the direction of play so we decided to derive a "Load per Play" value that will be acceleration summed per player per play.

As an extension to this, we will also derive a "Fatigue Index" based on the research by Beato et al., that will be a value of acceleration/speed for each value in time, i. 


## Methods
We will be creating two derived variables:

1.  (Cumulative) load by player by play
  - Load is the summation of acceleration across a game, and cumulative load sums these values on a game level.
2. Fatigue resistance index by player by play
  - The fatigue index will be calculated by performing acceleration/speed, which is a measure of explosiveness. Our change in fatigue resistance index over a game will indicate if a player became more or less explosive, with these values indicating fatigue resistance and fatigue, respectively.
  
These values will then be summarized by player, excluding players that do not have a significant number of entries in the dataset (these players are either injured or bench players).

We will then be visualizing the trend and seasonality of fatigue across the length of a game. This will allow us to find the averages of maximum acceleration, load, and fatigue values for a player across a season.

Our goal is to identify a relationship between player fatigue and penalties/positive tackles. Penalties will be grouped based on type.
1. Formation
  - Illegal Shift, Illegal Formation, Defensive Offside
2. Tackle
  - Defensive Holding, Horse Collar Tackle, Low Block, Illegal Use of Hands, Roughing the Passer

To identify fatigue-resistant players, we will perform a clustering analysis with demographic data and our derived variables from the tracking data. Then, we will summarize the average number of formation and tackle penalties for these clusters to understand the relationship between load/fatigue and penalties. We will be doing the same analysis for positive tackles.

Finally, we will extract the free agents from our clustering model to compare fatigue, penalties, and tackles among these linemen.


## Implementation
```{r libraries}
library(dplyr)
library(ggplot2)
library(lubridate)
library(tidyr)
library(gridExtra)
library(dendextend)
#library(mice)
library(cluster)
#library(factoextra)
library(ggrepel)
library(data.table)
library(rvest)

```

#### Data
Play Data for Each Player
```{r read data}
play <- read.csv('player_play.csv')
player_data <- read.csv('players.csv')
```

Filter to only defensive linemen.
- DE (Defensive End)
- DT (Defensive Tackle)
- NT (Nose Tackle)

```{r make def line}
def_line_players <- player_data[player_data$position == 'DE' | player_data$position == 'DT' |
                          player_data$position == 'NT',]

def_line <- play %>%
  right_join(def_line_players[, c("nflId", "position")], by = "nflId")

def_line <- def_line %>%
  select(-c('hadRushAttempt', 'rushingYards', 'hadDropback', 'passingYards', 'sackYardsAsOffense',
            'hadPassReception', 'receivingYards', 'wasTargettedReceiver', 'yardageGainedAfterTheCatch',
            'fumbles', 'fumbleLost', 'fumbleOutOfBounds', 'wasInitialPassRusher', 'wasRunningRoute',
            'routeRan', 'blockedPlayerNFLId1', 'blockedPlayerNFLId2', 'blockedPlayerNFLId3'))
```

Variables for defensive linemen: 
 - assistedTackle: required an assist to make a tackle
 - forcedFumbleAsDefense: forced a fumble by the opposing team
 - halfSackYardsAsDefense: yards conceded by the offense because of a half-sack
 - passDefensed: a passing play was stopped by the player
 - quarterbackHit: player recorded a QB hit
 - sackYardsAsDefense: yards conceded by the offense because of a sack by the player
 - safetyAsDefense: player forced a safety on this play
 - soloTackle: player recorded a solo tackle on this play
 - tackleAssist: player was awarded an assisted tackle
 - tackleForALoss: player recorded a tackle behind the line of scrimmage
 - tackleForALossYardage: yards conceded by the offense because of a tackle
 - hadInterception: player intercepted a pass
 - interceptionYards: yards returned by the player on an intercepted pass
 - fumbleRecoveries: number of fumbles recovered by the player
 - fumbleRecoveryYards: yards returned by the player on a fumble recovery
 - penaltyNames
 - causedPressure: player pressured the QB
 - timeToPressureAsPassRusher: time elapsed from snap to player reaching a pressure pro. >= to 0.75
 - inMotionAtBallSnap: player was in motion at snap
 - shiftSinceLineset: player shifted since the lineset
 - pressureAllowedAsBlocker: any pass rushers that the blocker had a true matchup against recorded a pressure
 - timeToPressureAllowedAsBlocker: time from snap to pass rusher who blocker had true matchup against achieving a pressure prob. > 0.75
 - pff_defensiveCoverageAssignment: defensive coverage assignment given to the player
 
```{r}
summary(def_line)
unique(def_line$gameId)
```

Tracking Data
```{r load data, eval = FALSE}
#week1 <- fread('tracking_week_1.csv')
# week2 <- read.csv('tracking_week_2.csv')
# week3 <- read.csv('tracking_week_3.csv')
# weeks <- rbind(week1, week2, week3)

weeks <- data.frame(fread("weeksAll.csv"))
dim(weeks)
#save(weeks, file = "weeks123.RData")
weeks$time <- as.POSIXct(weeks$time)
unique(weeks$gameId)
summary(weeks)
```

```{r}
# Specify the directory containing your CSV files
directory <- "nfl-big-data-bowl-2025"

# Get the list of all CSV files in the directory
file_list <- list.files(path = directory, pattern = "*.csv", full.names = TRUE)
weeks <- fread(file_list[1], header = TRUE)
# Read and combine all CSV files
weeks <- rbindlist(lapply(file_list[2:9], fread)) # View the first few rows of the combined dataframe 
# dim(weeks)
# weeks$time <- as.POSIXct(weeks$time)
# unique(weeks$gameId)
# summary(weeks)
```

The following variables from the tracking data can be used to calculate fatigue:
 - s (speed), a (acceleration)
 
Join Data
```{r join}
data <- inner_join(def_line, weeks, by = c("gameId", "playId", "nflId"))
saveRDS(data, file = "joinedData.RData")
```

```{r}
# load("joinedData.RData")
colnames(data)
head(data)
summary(data)
```

Two variables of importance are a player's load and fatigue index, which is equal to acceleration/speed. Let's visualize these for one player in one play. We want to look at movement only during/after the ball is snapped. We will filter the frameId to be within a small range of the snap and initial acceleration.

Fatigue Index Per Play: Acceleration/Speed.
This is a measure of player explosiveness.
```{r load per play}
ran_play <- data %>%
  filter(gameId == 2022090800) %>%
  filter(playId == 56) %>%
  filter(frameType != "BEFORE_SNAP") %>%
  filter(!is.na(position)) %>%
  filter(frameId <= 155) %>%
  mutate(fatigueIndex = a/s)
g <- ggplot(ran_play, aes(x=frameId, y = fatigueIndex, color = position)) + geom_point() + geom_smooth()
ggsave(plot= g, filename= "g.png")
g
```

We see initial explosiveness right when the ball is snapped and linemen are making their first movement.

Acceleration Per Play
```{r acc per play}
ran_play2 <- data %>%
  filter(gameId == 2022090800) %>%
  filter(playId == 56) %>%
  filter(frameType != "BEFORE_SNAP") %>%
  filter(!is.na(position)) %>%
  filter(frameId <= 160)
g1 <- ggplot(ran_play2, aes(x=frameId, y = a, color = position)) + geom_point() + geom_smooth()
ggsave(plot= g1, filename= "g1.png")
g1
```

In terms of acceleration, we see this value increase after the ball is snapped and then decrease later in the play.

#### Derived Variables

Our derived variables will be calculated on a per-play level.

Player Load = SUM(Acceleration)
Max Acceleration = MAX(Acceleration)
```{r calculate load}
data <- data %>%
  filter(frameType != 'BEFORE_SNAP') %>%
  group_by(gameId, playId, nflId) %>%
  mutate(load = sum(a, na.rm = TRUE),
         max_acc = max(a)) %>% ungroup()

head(data)
```

Cumulative load will be calculated on a per-game level.

Cumulative Load = CUMSUM(load)
```{r calculate cumulative load}
per_play <- data %>%
  select(gameId, playId, nflId, load, teamAbbr, position, max_acc, frameType,a, s) %>% distinct() %>%
  arrange(gameId, nflId, playId)
#head(per_play)

per_play <- per_play %>%
  group_by(gameId, nflId) %>%
  mutate(cum_load = cumsum(load))
head(per_play)
```

#### Exploratory Analysis/Visualizations

Let's look at some of our variables across a play/game. We will subset our data to a random gameId and then select defensive linemen at random.

Load Per Player
```{r load per player plot}
game <- data[data$gameId == 2022090800,]
head(game)
dim(game)

# select 10 defensive linemen at random
set.seed(456)
ran_nflIds <- sample(game$nflId, 10)

for (id in ran_nflIds) {
  player_plot <- game %>% filter(nflId == id) %>% filter(frameId <= 160)
  load_plot <- ggplot(player_plot, aes(x = playId, y = load)) +
    geom_point() + 
    geom_smooth(method = "loess", color = "blue") + 
    labs(x = "Play ID", y = "Load", title = paste0("Player Load in Game - NFL ID: ", id)) +
    theme_minimal()

  print(load_plot)
  ggsave(plot= load_plot, filename= "load_plot.png")
  
}
```

We hypothesized that total load would decrease later in the game because a player would be more fatigues. For most of the linemen, we see a slight decline throughout the game when looking at their initial load (beginning of game) to final load (end of game). 

Let's also look at cumulative load over a game. 
```{r cum load over game plot}
game <- per_play[per_play$gameId == 2022090800,]

# select 10 defensive linemen at random
set.seed(456)
ran_nflIds <- sample(game$nflId, 10)

for (id in ran_nflIds) {
  player_plot <- game %>% filter(nflId == id)
  c_load_plot <- ggplot(player_plot, aes(x = playId, y = cum_load)) +
    geom_smooth(method = "loess", color = "blue") + 
    labs(x = "Play ID", y = "Cumulative Load", title = paste0("Player Cum. Load in Game - NFL ID: ", id)) +
    theme_minimal()

  print(c_load_plot)
  ggsave(plot = c_load_plot, filename = "c_load_plot.png")
}
```

For cumulative load, we see a steady increase across a game for the majority of our randomly selected players.

In addition to this measure of calculating total load using the sum of accelerations, we can also look at the change in the fatigue analysis of a player. Change in fatigue will incorporate both player speed and acceleration during the play. A higher fatigue index (acceleration/speed) indicates a more aggressive change in speed, so we would expect fatigue index to decrease as a player gets tired (throughout a game).

Fatigue Index over a Game
```{r fatigue index calc}
for (id in ran_nflIds) {
  player_plot <- game %>% filter(nflId == id) %>% filter(frameType != "BEFORE_SNAP") %>% mutate(fatigueIndex = a/s) %>% filter(is.numeric(fatigueIndex) & !(fatigueIndex == Inf)) %>% mutate(avgFI = mean(fatigueIndex)) %>% group_by(playId) %>% mutate(maxFI = max(fatigueIndex), countFI =sum(fatigueIndex >= avgFI)) %>% #countFI is a count per play that the fatigue index is over the average fatigue index per the game
    select(playId, countFI, maxFI) %>% distinct()
  load_plot <- ggplot(player_plot, aes(x = playId, y = maxFI)) +
    geom_point() + 
    geom_smooth(method = "loess", color = "blue") + 
    labs(x = "Play ID", y = "Max FI Per Play", title = paste0("Player Fatigue Resistance Index in Game - NFL ID: ", id)) +
    theme_minimal()

  print(load_plot)
  ggsave(plot = load_plot, "load_plot.png")
}
```

There is some variation across players regarding their change in max fatigue index. Whilst some do go down as the game goes on, there are others that stay level or even increase towards the end of the game. These players with a steady fatigue index value are not becoming fatigues throughout a game, while others suffer from fatigue and we see this measure of "explosiveness" decrease.

It is worth noting this is just one game and a random sample of players so it is very individualized. Once we generalize the data across all games and all players, we would hope to see more of a consistent trend.

In addition to our derived variables, we will also be using demographic variables in our analysis. Player height and weight may also have a relationship with acceleration. Let's visualize this relationship.

Effect of Demographics on Median Acceleration
```{r demographics}
max_acc <- data %>% group_by(nflId) %>% mutate(max_acc = mean(a)) %>% select(nflId, max_acc) %>% distinct()
demographic <- max_acc %>% inner_join(def_line_players)
demographic$birthDate <- as.Date(demographic$birthDate)


# Function to convert feet-inches to centimeters 
convert_to_cm <- function(height)
  { height_parts <- strsplit(height, "-")[[1]] 
  feet <- as.numeric(height_parts[1]) 
  inches <- as.numeric(height_parts[2]) 
  total_inches <- feet * 12 + inches 
  total_cm <- total_inches * 2.54 
  return(total_cm) } # Apply the conversion to the height column 

demographic$height <- sapply(demographic$height, convert_to_cm)

demographic <- demographic %>% na.omit() %>% mutate(age = as.integer(round(as.Date(now()) - birthDate)/365))

# Scatter plot for age vs x
plot_age <- ggplot(demographic, aes(x = age, y = max_acc)) +
  geom_point() +
  labs(title = "Age vs Acceleration", x = "Age", y = "Avg Acceleration") +
  theme_minimal() +geom_smooth()

# Scatter plot for height vs x
plot_height <- ggplot(demographic, aes(x = height, y = max_acc)) +
  geom_point() +
  labs(title = "Height vs Acceleration", x = "Height", y = "Avg Acceleration") +
  theme_minimal() +geom_smooth()

# Scatter plot for weight vs x
plot_weight <- ggplot(demographic, aes(x = weight, y = max_acc)) +
  geom_point() +
  labs(title = "Weight vs Acceleration", x = "Weight", y = "Avg Acceleration") +
  theme_minimal() +geom_smooth()
ggsave(plot= plot_age, filename = "plot_age.png")
ggsave(plot=plot_height, filename = "plot_height.png")
ggsave(plot=plot_weight, filename = "plot_weight.png")

grid.arrange(plot_age, plot_height, plot_weight, nrow = 1)

```

As one of the points of our analysis is to look for key factors that affect fatigue-resistant, we plotted the relationship between age, height and weight and median acceleration. As acceleration will be included in our derivation for "fatigue", we thought it would be interesting to see these relationships.

We would have thought as players get older and larger that acceleration decreases. However this was not the case, with only weight showing a marginally negative correlation. This probably means that other factors such as match-up and time played/time since last TO are more important factors.

With our fatigue analysis, we will also be looking at the outcome of the play. We have divided penalties into two main categories: tackle penalties (which happen during the play) and formation penalties (which happen before the play).
```{r penalties}
tackle_pen <- c("Horse Collar Tackle", "Defensive Holding", "Low Block", "Illegal Use of Hands", "Roughing the Passer", "Face Mask")
formation_pen <-  c("Illegal Shift", "Illegal Formation", "Defensive Offside")
```

Penalties Throughout a Game
```{r Tackles over Time}
play_details <- read.csv("plays.csv") %>% select(gameId, playId, quarter, gameClock)
head(play_details)

# penalties <- play %>% select(gameId, playId, nflId, penaltyNames) %>% full_join(play_details) %>% mutate(penaltyType = ifelse(penaltyNames %in% tackle_pen, "Tackle", ifelse(penaltyNames %in% formation_pen, "Formation", NA)), totalClock = (quarter-1) *  ms("15:00") +(ms("15:00")- ms(gameClock))) 


penalties <- play %>% select(gameId, playId, nflId, penaltyNames) %>% full_join(play_details) %>% mutate(penaltyType = ifelse(penaltyNames %in% tackle_pen, "Tackle", ifelse(penaltyNames %in% formation_pen, "Formation", NA)))
                                                                                                         
plot_data <- penalties %>% select(quarter, penaltyType) %>% na.omit() %>% group_by(quarter, penaltyType) %>% summarise(count = n()) %>% ungroup() 

stacked_bar <- ggplot(plot_data, aes(x = as.factor(quarter), y = count, fill = penaltyType)) +
  geom_bar(stat = "identity") +
  labs(title = "Penalties by Category and Quarter", x = "Quarter", y = "Count", fill = "Penalty Type") +
  theme_minimal()

stacked_bar
ggsave(plot=stacked_bar, filename = "stacked_bar.png")

# plot_data <- plot_data %>% na.omit()
# plot_data <- plot_data %>% pivot_wider(names_from = penaltyType, values_from = count, values_fill = list(count = 0))
# 
# plot_data <- penalties %>% select(gameId, playId, penaltyType) %>% distinct() %>% arrange(gameId)
# unique(plot_data$playId)
# 
# ggplot(data = plot_data) + geom_density(aes(x = totalClock, y = count, color = penaltyType))
# tail(penalties)
# unique(penalties$totalClock)
# ms("15:00")- ms(penalties$gameClock)

```

In our clustering methods, we will not be separating on a quarter-level, however, we wanted to visualize the number of penalties in our dataset. There is an increase in both types of penalties from the first to the second quarter, and an increase in formation penalties from the third to fourth quarter. We see slightly more tackle penalties in total; however, the dataset contains enough of both types of penalties to continue our analysis. 

#### Clustering Analysis

We are going to cluster players based on their:
  - maximum acceleration in a game,
  - change in fatigue index (a positive measure indicates fatigue-resistance),
  - average cumulative load in a game,
  - height
  - weight

Once we have clustered our defensive linemen, we will be adding other values to our clustering heatmaps:
  - *_AvgPerGame (penalties and defensive plays)
  - plays_count (number of plays)

```{r grouping}
# for each gameId, playId, nflId group: if any of the penalties match a value in tackle or formation penalties, set this value to 1
total_penalties <- function(penaltyNames, tackle_pen, formation_pen) {
  tacklePenalty = ifelse(any(penaltyNames %in% tackle_pen), 1, 0)
  formationPenalty = ifelse(any(penaltyNames %in% formation_pen), 1, 0)
  return(c(tacklePenalty, formationPenalty))
}

grouped <- data %>%
  group_by(gameId, playId, nflId) %>%
  mutate(FI = a/s) %>%
  filter(is.numeric(FI) & !(FI == Inf)) %>% #takes out any rows that will mess with avg and max FI calculations
  filter(FI <= mean(FI) + sd(FI)*2 & FI >= mean(FI) - sd(FI)*2) %>%
  mutate(
    penalty_values = list(total_penalties(penaltyNames, tackle_pen, formation_pen)),
    tackle_pen = penalty_values[[1]][1], 
    formation_pen = penalty_values[[1]][2],
    avg_fatigueIndex = sum(mean(a)/mean(s)),
    max_fatigueIndex = max(FI)) %>%
  select(gameId, playId, nflId, displayName, frameId, load, max_acc, penalty_values, tackle_pen, formation_pen, avg_fatigueIndex, max_fatigueIndex, FI)

changeFI <-  grouped  %>% group_by(nflId, gameId) %>% arrange(playId) %>% summarize(change_FI = first(max_fatigueIndex) - last(max_fatigueIndex))

grouped <- inner_join(grouped, changeFI, by = c("nflId", "gameId"))
```

Some values of average/max fatigue index are Infinite because the player's logged speed is 0. Let's impute 0 for those values.
```{r}
grouped$avg_fatigueIndex[is.infinite(grouped$avg_fatigueIndex)] <- 0
grouped$max_fatigueIndex[is.infinite(grouped$change_FI)] <- 0
saveRDS(grouped, "grouped.RData")
```


We need to add cumulative load and fatigueIndex to this dataset, making it on a per-play level.
```{r per play data}
test <- grouped %>%
  select(gameId, playId, nflId, load, displayName, max_acc, tackle_pen, formation_pen, max_fatigueIndex,  avg_fatigueIndex, change_FI) %>%
  distinct() %>%
  arrange(gameId, nflId, playId)

test <- test %>%
  group_by(gameId, nflId) %>%
  mutate(cum_load = cumsum(load))

head(test)
```

We also need to add player height, weight, and age from our demographic data.
```{r add demographics}
test <- test %>%
  left_join(player_data[, c("nflId", "height", "weight", "birthDate")], by = "nflId")
```

Now that we have a dataset with the necessary values for our clustering, we need to clean the height and birthDate columns. We will change height to an numeric inches value and birthDate to a numerical age.
```{r functions}
# height conversion
#class(test$height)
convert_to_inches <- function(height_str) {
  parts <- strsplit(height_str, "-")[[1]]
  feet <- as.numeric(parts[1])
  inches <- as.numeric(parts[2])
  total_inches <- (feet * 12) + inches
  return(total_inches)
}
test$height <- sapply(test$height, convert_to_inches)

# birthDate conversion
#class(test$birthDate)
convert_to_age <- function(birthdate) {
  birthdate <- as.Date(birthdate, format = "%Y-%m-%d")
  date <- Sys.Date()
  age <- as.numeric(difftime(Sys.Date(), birthdate, units = "weeks")) / 52.25
  return(floor(age))
}
test$age <- convert_to_age(test$birthDate)

saveRDS(test, "test.RData")

```

We want to analyze only players that occur many times in the dataset. We will eliminate players that only have a few total entries in the dataset, as these are not the starting players.
```{r top players}
players_top <- test %>% ungroup() %>% select(displayName) %>%
  group_by(displayName) %>% mutate(count = n()) %>% distinct()
nrow(players_top)
rows50 = floor(nrow(players_top) *0.50)
players_top <- players_top %>% arrange(desc(count))
players_top <- players_top[1:rows50,]
```

Selecting only these players will eliminate outliers - instances in which a player had only a few movements in a game or only had a few plays (either good or bad).

From our dataset, we will select columns to cluster:
 - max_acc
 - change_FI
 - cum_load
 - height
 - weight
 - age
```{r select cols}
clustering_columns <- c("max_acc", "change_FI", "cum_load", "height", "weight", "age")
```

Our dataframe for clustering with include one row per player in our dataset and include 6 metrics. We will take the clustering columns selected above and find the average value of these metrics for each player in our dataset.
```{r make df}
players <- unique(players_top$displayName)

res <- as.data.frame(matrix(NA, nrow = length(players), ncol = 6))

for(i in 1:length(players)){
  temp <- test[which(test$displayName == players[i]), ]
  
  res[i, 1:6] <- colMeans(temp[, clustering_columns], na.rm = TRUE) #average of all columns above
 
}

names(res) <- c("avg_max_acc", "avg_change_fatigueResistanceIndex","avg_cum_load", "height", "weight", "age")

rownames(res) <- players
summary(res)
```

All of the NA values present in the dataset are in the 'age' column. We will impute the mean value for these instances.
```{r impute values}
sum(is.na(res))
sum(is.na(res$age))

# imputed_data <- mice(res, m = 5, method = 'pmm', maxit = 50, seed = 500)
# impute_data <- complete(imputed_data, action = 1)

impute_mean <- function(x) {
  x[is.na(x)] <- mean(x, na.rm = TRUE) 
return(x) } # Apply the function to the dataframe 
impute_data <- data.frame(lapply(res, impute_mean))
sum(is.na(impute_data))
```

Now, let's scale clustering data. We have some negative values in our fatigue resistance index, so we will log this value separately before scaling.
```{r scale}
# Before scaling data, log transform.
all_data <- impute_data
all_data$avg_change_fatigueResistanceIndex <- log(abs(impute_data$avg_change_fatigueResistanceIndex) +1)* sign(impute_data$avg_change_fatigueResistanceIndex) #log separately because negative values

all_data[,-2] <- log(impute_data[,-2] + 1) 
 
 sdata <- scale(all_data)

#sdata <- cbind(sdata, avg_change_fatigueIndex = unscaled_col)
saveRDS(sdata, "scaled.RData")


```

Find the optimal number of clusters for analysis.
```{r optimal clusters}
gapData <- clusGap(sdata, FUNcluster = kmeans, K.max = 15)


gap_data <- data.frame( k = 1:15, gap = gapData$Tab[,"gap"], SE.sim = gapData$Tab[,"SE.sim"] )

plot_gap <- ggplot(gap_data, aes(x = k, y = gap)) + geom_line() + geom_point() + geom_errorbar(aes(ymin = gap - SE.sim, ymax = gap + SE.sim), width = 0.2) + labs(title = "Gap Statistic", x = "Number of Clusters", y = "Gap Value") + theme_minimal()

plot_gap
#fviz_gap_stat(gapData)- doesnt like package in ssh
saveRDS(plot_gap, "gapData.RData")
```

We will continue with four clusters because it provides enough disparity between groups. 

Let's now run k-means clustering on the data.
```{r k means}
set.seed(12345) 

fit <- kmeans(x = sdata,
                centers = 4, 
                nstart = 25, 
                iter.max = 100)
clusters <- fit$cluster
centers <- fit$centers

# number of linemen in each cluster
summary(as.factor(clusters))

saveRDS(fit, "clusterModel.RData")
```


```{r centers}
cluster <- c(1:4)
center_df <- data.frame(cluster, centers)

center_reshape <- gather(center_df, features, values, -cluster)
saveRDS(center_reshape, "heatmap1.RData")
```

Heatmap of our clusters.
```{r heatmap}
heatmap <- ggplot(data = center_reshape, 
                   aes(x = features, y = cluster, fill = values)) + 
  scale_y_continuous(breaks = seq(1, 8, by = 1)) + 
  geom_tile() + 
  coord_equal() + 
  theme_bw() + 
  scale_fill_gradient2(low = "blue", 
                       mid = "white", 
                       high = "red",
                       midpoint =0, 
                       space = "Lab", 
                       na.value ="grey", 
                       guide = "colourbar", 
                       aesthetics = "fill") + 
  coord_flip() 

heatmap
ggsave(plot=heatmap, filename = "heatmap.png")
```

In looking at our heat map, clusters 2, 3 and 4 are the most fatigue resistant compared to cluster 1 that struggles a lot to maintain explosiveness. In looking at demographics, cluster 2 contains the lightest players, cluster 3 contains the tallest and oldest players, and clusters 1 and 4 contain roughly the same demographic of players with the cluster 4 players being slightly shorter.

We see cluster 2 having the highest acceleration values and cumulative load in a game. On the other hand, cluster 4 has the highest fatigue resistance, but these players are taking on a lesser load compared to the players in cluster 2.

##### Part 1

Now, we can add total penalties to the clusters.

First, let's assign cluster number to player name.
```{r player clusters}
player_clusts <- data.frame(player_name = players, cluster = clusters)
rownames(player_clusts) <- NULL
saveRDS(player_clusts, "player_clusts.RData")

```

```{r add penalties}
# sum_pen <- as.data.frame(matrix(NA, nrow = nrow(player_clusts), ncol = 2))
# 
# for(i in 1:nrow(player_clusts)){
#   temp <- test[which(test$displayName == player_clusts$player_name[i]), ]
#   
#   sum_pen[i, 1] <- sum(temp$tackle_pen, na.rm = TRUE)
#   sum_pen[i, 2] <- sum(temp$formation_pen, na.rm = TRUE)
# }
# 
# colnames(sum_pen) <- c("total_tackle_pen", "total_formation_pen")
# sum_pen <- cbind(player_clusts, sum_pen)
names_penalties <- test %>% group_by(displayName) %>% summarise( avg_formation = mean(formation_pen), avg_tackle = mean(tackle_pen), avg_pen = mean(tackle_pen+formation_pen)) %>% inner_join(player_clusts, by = c("displayName" = "player_name"))


penalties_perGame <- test %>% group_by(displayName, gameId) %>% summarise( avg_formation = mean(formation_pen), avg_tackle = mean(tackle_pen)) %>% inner_join(player_clusts, by = c("displayName" = "player_name")) %>% ungroup() %>% select(-gameId, -displayName) %>% group_by(cluster) %>% summarise(avg_formation_perGame = mean(avg_formation), avg_tackle_perGame = mean(avg_tackle)) %>% gather( key="features", value="values", -cluster) #pivot longer 
penalties_perGame$values = scale(penalties_perGame$values )
```

Let's add these penalty calculations back to our cluster dataframe and create a new heatmap.
```{r new scaling}
# totals_scaled <- scale(totals)
# new_center_df <- cbind(center_df, totals_scaled)
# 
# new_center_reshape <- gather(new_center_df, features, values, avg_max_acc:formation_pen_percent)

new_center_reshape <- gather(center_df, features, values,-cluster) %>% rbind(penalties_perGame)
saveRDS(new_center_reshape, "heatmap2.RData")

```

New heatmap with penalties.
```{r new heatmap}
heatmap2 <- ggplot(data = new_center_reshape, 
                   aes(x = features, y = cluster, fill = values)) + 
  scale_y_continuous(breaks = seq(1, 8, by = 1)) + 
  geom_tile() + 
  coord_equal() + 
  theme_bw() + 
  scale_fill_gradient2(low = "blue", 
                       mid = "white", 
                       high = "red",
                       midpoint =0, 
                       space = "Lab", 
                       na.value ="grey", 
                       guide = "colourbar", 
                       aesthetics = "fill") + 
  coord_flip() 

heatmap2
ggsave(plot=heatmap2, filename = "heatmap2.png")
```

###### Heatmap Analysis with Penalties

From this clustering analysis, we see some patterns in terms of penalties.

Players in cluster 2 were those with higher loads and acceleration values. These linemen were pretty fatigue resistant. When adding in penalties, we see that those in cluster 2 have the highest value for formation penalties in a game. This could be because these players are so explosive in their acceleration, they might be moving too early and getting called for defensive offsides.

Cluster 4 has a lower load and acceleration than cluster 2 and is also good at resisting fatigue. Players in this cluster do not have high numbers of either type of penalty, which indicated their reliability across a game as a result of fatigue resistance.

Cluster 1 includes players that suffer from fatigue in a game. Suprisingly, these players also have low numbers of both penalties. This could be because they don't have the explosiveness or aggression that normally comes with penalites.

Other areas of interest are the positive relationship between age and tackling penalties seen in cluster 3 and the inverse relationship between max acceleration and number of formation penalties. We also see a positive relationship between weight and the number of formation penalties.

##### Part 2
Now let's see the influence of these similar "fatigue" and "demographic" variables on positive defensive performance, rather than negative penalties.

The positive values we will look at:
 - forcedFumbleAsDefense: forced a fumble by the opposing team
 - halfSackYardsAsDefense: yards conceded by the offense because of a half-sack
 - passDefensed: a passing play was stopped by the player
 - quarterbackHit: player recorded a QB hit
 - sackYardsAsDefense: yards conceded by the offense because of a sack by the player
 - soloTackle: player recorded a solo tackle on this play
 - tackleAssist: player was awarded an assisted tackle
 - tackleForALoss: player recorded a tackle behind the line of scrimmage
 - tackleForALossYardage: yards conceded by the offense because of a tackle
```{r}
positive_defense <- data %>% group_by(nflId) %>%
  select(gameId, playId, nflId, forcedFumbleAsDefense, passDefensed, quarterbackHit, soloTackle, tackleAssist, tackleForALoss) %>% group_by(gameId, playId, nflId) %>% summarise(across(everything(), ~ as.integer(any(. == 1))))

counts_4weeks <- positive_defense %>% ungroup()%>% select(-c(gameId, playId, nflId)) %>% summarise_all(sum)


#Number of each occurence over the weeks
counts_4weeks

positive_defense_yds <- data %>% group_by(nflId) %>%
  select(gameId, playId, nflId, halfSackYardsAsDefense, sackYardsAsDefense, tackleForALossYardage) %>% group_by(gameId, playId, nflId) %>% summarise(across(everything(), ~ as.integer(any(. == 1))))

counts_yds_4weeks <- positive_defense_yds %>% ungroup()%>% select(-c(gameId, playId, nflId)) %>% summarise_all(mean)
counts_yds_4weeks


#Shows there is very little recorded in terms of yardage lost because of d-line. We are better off using the binary values
counts_yds_4weeks


positive_defense <- positive_defense %>% ungroup() %>% inner_join(player_data %>% select(nflId, displayName))
summary_def <- positive_defense %>% select(-playId) %>% group_by(displayName) %>% summarise_all(mean) #avg per player per game num of each def

new_col_names <- names(summary_def)
new_col_names[4:9] <- paste0(new_col_names[4:9], "_AvgPerGame") 
summary_def <- setNames(summary_def, new_col_names)

summary_def <- summary_def %>% select(-gameId, -nflId)
scaled_count <- data.frame(cbind(displayName = players_top$displayName,  scale(players_top$count))) %>% inner_join(player_clusts, by = c("displayName" =  "player_name")) %>% rename(play_count = V2) %>% mutate(play_count =as.numeric(play_count))



play_counts <- inner_join(players_top, player_clusts, by = c("displayName" =  "player_name")) %>% rename(plays_count = count)

#player_clust < summary_def as it is filtered to just top players
player_clust_def <- right_join(summary_def, play_counts, by = c("displayName")) %>% na.omit()


clustered_def <- player_clust_def %>% group_by(cluster) %>% select(-displayName) %>% summarise_all(mean) #summarise avg of players in cluster

scaled <- data.frame(scale(clustered_def %>% select(-cluster))) %>% cbind(cluster = c(1,2,3,4)) #scaling

new_clustered_def <- inner_join(scaled, center_df, by = "cluster") #joining with clustered "fatigue stats"

new_clustered_def <- new_clustered_def %>% gather( key="features", value="values", -cluster) #pivot longer 
saveRDS(new_clustered_def, "heatmap3.RData")

```

```{r}
heatmap3 <- ggplot(data = new_clustered_def, 
                   aes(x = features, y = cluster, fill = values)) + 
  scale_y_continuous(breaks = seq(1, 8, by = 1)) + 
  geom_tile() + 
  coord_equal() + 
  theme_bw() + 
  scale_fill_gradient2(low = "blue", 
                       mid = "white", 
                       high = "red",
                       midpoint =0, 
                       space = "Lab", 
                       na.value ="grey", 
                       guide = "colourbar", 
                       aesthetics = "fill") + 
  coord_flip() 

heatmap3
ggsave(plot=heatmap3, filename = "heatmap3.png")
```

###### Heatmap Analysis with Positive Defensive Plays

We can see a split in the clusters with them tending towards either of the following groups.

Group 1: Defensive Impact Plays
These stats reflect high-impact plays that significantly disrupt the offense or stop their progress forcefully.

- forcedFumbleAsDefense
- quarterbackHit
- soloTackle
- tackleForALoss


Group 2: Supportive Defensive Plays
These stats highlight plays where the defender provides crucial support, either by assisting or directly preventing a successful offensive move.

- passDefensed
- tackleAssist

Cluster 1 is best at the supportive defensive plays, mid-range for demographics, struggle heavily with fatigue despite having low cumulative load and low acceleration, they cannot maintain it.

Cluster 2 is significantly best at defensive impact plays, lightest, good at resisting fatigue despite high plays, load and acceleration.

Cluster 3 is only really good for tackle assistance so they are not making big real-time plays themselves, oldest and tallest, play the least and have relatively low load and acceleration but are good at maintaining it.

Cluster 4 is alright for the supportive defensive plays, shortest, average for amount they play, their load and acceleration but good at maintaining and resisting fatigue

__Cluster 2 is significantly best when looking holistically at defensive metrics and resistance of fatigue. Cluster 1 and 4 are both more geared towards supportive plays, but if we want to consider both production and fatigue resistance, cluster 4 is holistically better.__


### Clusters by Player

Now that we have analyzed these clusters, let's look at the players that make up each.
```{r}
plot1 <- res %>% select(avg_change_fatigueResistanceIndex, avg_cum_load) 
plot1$player_name <- rownames(plot1)
plot1 <- inner_join(plot1, player_clusts)
plot1$cluster <- as.factor(plot1$cluster)

saveRDS(plot1, "playerplot1.RData")


g_1 <- ggplot(plot1, # Set dataset
              aes(x = avg_change_fatigueResistanceIndex,  # Set x-axis as number of fastballs
                  y = avg_cum_load, color = cluster)) + # Set y-axis as fastball speed
  geom_point() + # Add geom point for scatter plot
  # Label players with fastball speed above 95
  geom_text_repel(data = plot1,
                  aes(label = paste(player_name))) +
   theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid
  labs(x = "Avg Change Fatigue Resistance Index", y = "Avg Cumulative Load",
       title = "Defensive Line by Cluster- Fatigue Resistance",
       subtitle = "NFL 2022")
g_1
ggsave(plot= g_1, filename= "g_1.png")
```

In this plot, the best location for a player is the upper-right corner. These players have a high load throughout a game, but are not getting fatigued. Those on the bottom right are not getting fatigued either, however, these players are taking on a lower load throughout a game.

```{r}
plot2 <- inner_join(summary_def, names_penalties) %>% mutate(cluster = as.factor(cluster)) %>% mutate(composite_pos = rowSums(select(., 2:7)))

saveRDS(plot2, "playerplot2.RData")
g_2 <- ggplot(plot2, # Set dataset
              aes(x = composite_pos,  # Set x-axis as number of fastballs
                  y = avg_pen, color = cluster)) + # Set y-axis as fastball speed
  geom_point() + # Add geom point for scatter plot
  # Label players with fastball speed above 95
  geom_text_repel(data = plot2,
                  aes(label = paste(displayName))) +
   theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid
  labs(x = "Composite Positive Defensive Metric Per Game", y = "Avg Total Penalties per Game",
       title = "Defensive Line by Cluster- Tackles vs Penalties",
       subtitle = "NFL 2022")
g_2
ggsave(plot= g_2, filename= "g_2.png")
```

In this plot, the best location for a player is the bottom-right corner. These players are making the most positive plays, however, they have the least number of tackles.

We added both penalties and positive plays to our fatigue clustering. Whilst the above plots show fatigue and then tackles/plays it is important to consider both metrics together. Depending on the needs of the team, if they are more focused on production and focused about players resisting fatigue (perhaps they have a large bench), they may interpret our analysis differently to a team that is looking for a single player, who may not be as effective in positive production but can keep the intensity throughout the whole game.

## Free Agent Selection

Now, let's focus only on free agents.
```{r curr free agents}
page = read_html("https://www.spotrac.com/nfl/free-agents/_/year/2024/status/available/sort/contract_value")
free_tbl <- data.frame(html_table(page)[[1]] )
names(free_tbl)[1] <- "displayName"

free_tbl <- free_tbl %>% filter(displayName %in% unique(test$displayName))
free_tbl <- free_tbl %>% filter(displayName %in% unique(players_top$displayName))


plot3 <- inner_join(plot1 %>% select(-cluster), plot2, by = c("player_name" = "displayName"))%>% filter(player_name %in% free_tbl$displayName) %>% mutate(composite = rowSums(select(., 4:12)))
 
g_3 <- ggplot(plot3, # Set dataset
              aes(x = avg_change_fatigueResistanceIndex,  # Set x-axis as number of fastballs
                  y = avg_cum_load, color = cluster, size = composite, alpha = 0.7)) + # Set y-axis as fastball speed
  geom_point() + # Add geom point for scatter plot
  geom_text_repel(data = plot3,
                  aes(label = paste(player_name))) +
   theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid
  labs(x = "Avg Change Fatigue Resistance Index", y = "Avg Cumulative Load",
       title = "Defensive Line by Cluster- Fatigue Resistance",
       subtitle = "NFL 2022")+ guides(alpha = "none")
g_3

g_4 <- ggplot(plot3, # Set dataset
              aes(x = avg_change_fatigueResistanceIndex,  # Set x-axis as number of fastballs
                  y = avg_cum_load, color = cluster, size = avg_pen, alpha = 0.7)) + # Set y-axis as fastball speed
  geom_point() + # Add geom point for scatter plot
  geom_text_repel(data = plot3,
                  aes(label = paste(player_name))) +
   theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid
  labs(x = "Avg Change Fatigue Resistance Index", y = "Avg Cumulative Load",
       title = "Defensive Line by Cluster- Fatigue Resistance",
       subtitle = "NFL 2022")+ guides(alpha = "none")
g_4
```

Based on the current free agents that are available, we would recommend Armon Watts. According to our analysis that includes fatigue resistance, defensive production and penalties, Watts is the best holistic pick. He scores highly on our fatigue resistance index, meaning he can maintain explosiveness throughout the whole game. Whilst not the highest, he has good positive defensive production especially compared to other "fatigue-resistant" players and miantain a low numbers penalties. From this, he would be a reliable player to use throughout the whole game, including clutch moments at the end where teams cannot afford defensive linemen giving up penalties at the end of a cloes game.

## Conclusion & Recommendations

In our clustering analysis, we highlighted clusters 2 and 4. Both these clusters exhibit fatigue resistance whilst producing good defensive metrics. Individuals in cluster 2 are lighter, have a higher acceleration, and are key in impact defensive plays. They do not have an overwhelming number of penalties in either category.

Individuals in cluster 4 are heavier and key in supportive defensive plays and also the most resistant to fatigue. These would be reliable players through a whole game, helping teammates make big plays whilst not making mistakes themselves. It is likely you would not need a high number of cluster 4 players as they would likely not need to be subbed frequently.

For the remaining two clusters, 1 and 3, these players either have weaknesses in fatigue resistance (1) or penalties and defensive production (3). After training or at the start/end of a season, any coach or team can rerun our clustering analysis to see if individual players any these clusters have shifted. This would indicate that players have become more/less fatigue resistant or are making more defensive plays/less mistakes, and then training can be adjusted accordingly.

In future work, we would like to apply a similar fatigue analysis to other player groups, such as quarterbacks, running backs, and offensive linemen or make our analysis more specific to one position-type to allow for less inter-position variation.

## Contribution
Imogen Meers & Sarah Deussing

## Bibliography
Alghannam, Abdullah F. “Metabolic limitations of performance and fatigue in football.” Asian journal of sports medicine vol. 3,2 (2012): 65-73. doi:10.5812/asjsm.34699

Beato, Marco et al. “Monitoring Fatigue During Intermittent Exercise With Accelerometer-Derived Metrics.” Frontiers in physiology vol. 10 780. 26 Jun. 2019, doi:10.3389/fphys.2019.00780

Finster-Rowen, Alex. "What is Player Load?" Catapult Sports. Catapult Sports, n.d. Web.



