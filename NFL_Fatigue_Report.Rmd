---
title: "NFL Fatigue Analysis in Defensive Linemen"
author: "Sarah Deussing & Imogen Meers"
date: "2024-11-11"
output:
  pdf_document: default
  html_document: default
---

## Motivation
Our analysis will study fatigue in defensive linemen using their speed, acceleration, distance traveled, and orientation. We will be calculating a player load and analyze the defensive player's effectiveness. To do so, we will combine this movement data with play outcome data - if the player sacked the quarterback, had a solo tackle, etc.

The outcome of our analysis will be to predict likelihood of "mistakes" and positive plays, based on player fatigue and other game-time variables and to identify if specific players are more fatigue-resistant.

There has been published research on long-term fatigue and "burnout" in NFL players over the course of their careers, which focuses on long-term health and physiological effects. There has also been research on game day fatigue in European Football to determine limitations on performance based on fatigue, in order to create suitable, enhancing interventions (Alghannam). However, there is no player specific or NFL game day based fatigue analysis, which is what will set our project apart.


## Research
We wanted to find a measure of fatigue that was derived from tracking data. From an study on _Monitoring Fatigue During Intermittent Exercise With Accelerometer-Derived Metrics_ and Catapult's own description of Player Load, we found this idea of "Dynamic Load", that is a sum of triaxial acceleration across a set time period. We do not have acceleration in three plains but we do have an acceleration in the direction of play so we decided to derive a "Load per Play" value that will be acceleration summed per player per play.

As an extension to this, we will also derive a "Fatigue Index" based on the research by Beato et al., that will be a value of acceleration/speed for each value in time, i.


## Problem framing
We will be creating two derived variables:

- Load by player by play
- Fatigue index by player by play

Perform a time-series analysis over the length of a game/period to see trend and seasonality of fatigue and the change in fatigue at specific events, e.g. "mistakes".

Define mistake as penalties that will be grouped based on type:
- Formation
  - Illegal Shift, Illegal Formation, Defensive Offside

- Tackle
  - Defensive Holding, Horse Collar Tackle, Low Block, Illegal Use of Hands, Roughing the Passer

Use player demographic data, time, tracking and load data to predict probability of "mistake" at a given time.

Use player demographic data, time, tracking and load data to predict positive defensive outcomes such as sacks, pressure and fumbles.

Identify fatigue-resistant players and cluster to see if they have similar demographic characteristics.

## Data overview
The dataset is a part of the NFL Big Data Bowl 2025, and it is taken from:
https://www.kaggle.com/competitions/nfl-big-data-bowl-2025/data 

We are going to use four main parts of the dataset: player_play, players, plays, and the tracking data for each week.

The player_play data contains information about the action of the play, including its outcome or any penalties. Each row corresponds to one player's individual actions for each play within a game.

The players data contains information about each player, including position, height, weight, and college. We will use this data to filter to only defensive linemen within all data sets.

The plays data contains information about the quarter, time, and contents of each play.

The tracking data has the x-coordinate, y-coordinate, direction, orientation, speed, and acceleration for each player involved in each play in a game. We will use this movement data to calculate player fatigue. This tracking data is available for all 9 weeks of the season.

The datasets can be joined on: gameId, playId, and nflId.

## Contribution
Imogen Meers & Sarah Deussing

## Bibliography
Alghannam, Abdullah F. “Metabolic limitations of performance and fatigue in football.” Asian journal of sports medicine vol. 3,2 (2012): 65-73. doi:10.5812/asjsm.34699

Beato, Marco et al. “Monitoring Fatigue During Intermittent Exercise With Accelerometer-Derived Metrics.” Frontiers in physiology vol. 10 780. 26 Jun. 2019, doi:10.3389/fphys.2019.00780

Finster-Rowen, Alex. "What is Player Load?" Catapult Sports. Catapult Sports, n.d. Web.


## Implementation
```{r libraries}
library(dplyr)
library(ggplot2)
library(lubridate)
library(tidyr)
library(gridExtra)
library(dendextend)
#library(mice)
library(cluster)
#library(factoextra)
library(ggrepel)
library(data.table)
library(rvest)

```

#### Data
Play Data for Each Player
```{r read data}
play <- read.csv('player_play.csv')
player_data <- read.csv('players.csv')
```

Filter to only defensive linemen.
- DE (Defensive End)
- DT (Defensive Tackle)
- NT (Nose Tackle)

```{r make def line}
def_line_players <- player_data[player_data$position == 'DE' | player_data$position == 'DT' |
                          player_data$position == 'NT',]

def_line <- play %>%
  right_join(def_line_players[, c("nflId", "position")], by = "nflId")

def_line <- def_line %>%
  select(-c('hadRushAttempt', 'rushingYards', 'hadDropback', 'passingYards', 'sackYardsAsOffense',
            'hadPassReception', 'receivingYards', 'wasTargettedReceiver', 'yardageGainedAfterTheCatch',
            'fumbles', 'fumbleLost', 'fumbleOutOfBounds', 'wasInitialPassRusher', 'wasRunningRoute',
            'routeRan', 'blockedPlayerNFLId1', 'blockedPlayerNFLId2', 'blockedPlayerNFLId3'))
```

Variables for defensive linemen: 
 - assistedTackle: required an assist to make a tackle
 - forcedFumbleAsDefense: forced a fumble by the opposing team
 - halfSackYardsAsDefense: yards conceded by the offense because of a half-sack
 - passDefensed: a passing play was stopped by the player
 - quarterbackHit: player recorded a QB hit
 - sackYardsAsDefense: yards conceded by the offense because of a sack by the player
 - safetyAsDefense: player forced a safety on this play
 - soloTackle: player recorded a solo tackle on this play
 - tackleAssist: player was awarded an assisted tackle
 - tackleForALoss: player recorded a tackle behind the line of scrimmage
 - tackleForALossYardage: yards conceded by the offense because of a tackle
 - hadInterception: player intercepted a pass
 - interceptionYards: yards returned by the player on an intercepted pass
 - fumbleRecoveries: number of fumbles recovered by the player
 - fumbleRecoveryYards: yards returned by the player on a fumble recovery
 - penaltyNames
 - causedPressure: player pressured the QB
 - timeToPressureAsPassRusher: time elapsed from snap to player reaching a pressure pro. >= to 0.75
 - inMotionAtBallSnap: player was in motion at snap
 - shiftSinceLineset: player shifted since the lineset
 - pressureAllowedAsBlocker: any pass rushers that the blocker had a true matchup against recorded a pressure
 - timeToPressureAllowedAsBlocker: time from snap to pass rusher who blocker had true matchup against achieving a pressure prob. > 0.75
 - pff_defensiveCoverageAssignment: defensive coverage assignment given to the player
 
```{r}
summary(def_line)
unique(def_line$gameId)
```

Tracking Data
```{r load data, eval = FALSE}
week1 <- fread('tracking_week_1.csv')
# week2 <- read.csv('tracking_week_2.csv')
# week3 <- read.csv('tracking_week_3.csv')
# weeks <- rbind(week1, week2, week3)

weeks <- data.frame(fread("weeksAll.csv"))
dim(weeks)
#save(weeks, file = "weeks123.RData")
weeks$time <- as.POSIXct(weeks$time)
unique(weeks$gameId)
summary(weeks)
```

```{r}
# Specify the directory containing your CSV files
directory <- "nfl-big-data-bowl-2025"

# Get the list of all CSV files in the directory
file_list <- list.files(path = directory, pattern = "*.csv", full.names = TRUE)
weeks <- fread(file_list[1], header = TRUE)
# Read and combine all CSV files
weeks <- rbindlist(lapply(file_list[2:9], fread)) # View the first few rows of the combined dataframe 
# dim(weeks)
# weeks$time <- as.POSIXct(weeks$time)
# unique(weeks$gameId)
# summary(weeks)
```

The following variables from the tracking data can be used to calculate fatigue:
 - s (speed), a (acceleration), dis (distance traveled), dir (direction), o (orientation) 
 
Join Data
```{r join}
data <- inner_join(def_line, weeks, by = c("gameId", "playId", "nflId"))
saveRDS(data, file = "joinedData.RData")
```

```{r}
# load("joinedData.RData")
colnames(data)
head(data)
summary(data)
```

Two variables of importance are a player's load and fatigue index, which is equal to acceleration/speed. Let's visualize these for one player in one play. We want to look at movement only during/after the ball is snapped. We will filter the frameId to be within a small range of the snap and initial acceleration.

Load Per Play
```{r load per play}
ran_play <- data %>%
  filter(gameId == 2022090800) %>%
  filter(playId == 56) %>%
  filter(frameType != "BEFORE_SNAP") %>%
  filter(!is.na(position)) %>%
  filter(frameId <= 155) %>%
  mutate(fatigueIndex = a/s)
g <- ggplot(ran_play, aes(x=frameId, y = fatigueIndex, color = position)) + geom_point() + geom_smooth()
ggsave(plot= g, filename= "g.png")


```

Acceleration Per Play
```{r acc per play}
ran_play2 <- data %>%
  filter(gameId == 2022090800) %>%
  filter(playId == 56) %>%
  filter(frameType != "BEFORE_SNAP") %>%
  filter(!is.na(position)) %>%
  filter(frameId <= 160)
g1 <- ggplot(ran_play2, aes(x=frameId, y = a, color = position)) + geom_point() + geom_smooth()
ggsave(plot= g1, filename= "g1.png")
g1
```

#### Derived Variables

Our derived variables will be calculated on a per-play level.

Player Load = SUM(Acceleration)
Max Acceleration = MAX(Acceleration)
```{r calculate load}
data <- data %>%
  filter(frameType != 'BEFORE_SNAP') %>%
  group_by(gameId, playId, nflId) %>%
  mutate(load = sum(a, na.rm = TRUE),
         max_acc = max(a)) %>% ungroup()

head(data)
```

Cumulative Load = CUMSUM(load)
```{r calculate cumulative load}
per_play <- data %>%
  select(gameId, playId, nflId, load, teamAbbr, position, max_acc, frameType,a, s) %>% distinct() %>%
  arrange(gameId, nflId, playId)
#head(per_play)

per_play <- per_play %>%
  group_by(gameId, nflId) %>%
  mutate(cum_load = cumsum(load))
head(per_play)
```

#### Exploratory Analysis/Visualizations

Load Per Player
```{r load per player plot}
game <- data[data$gameId == 2022090800,]
head(game)
dim(game)

# select 10 defensive linemen at random
set.seed(456)
ran_nflIds <- sample(game$nflId, 10)

for (id in ran_nflIds) {
  player_plot <- game %>% filter(nflId == id) %>% filter(frameId <= 160)
  load_plot <- ggplot(player_plot, aes(x = playId, y = load)) +
    geom_point() + 
    geom_smooth(method = "loess", color = "blue") + 
    labs(x = "Play ID", y = "Load", title = paste0("Player Load in Game - NFL ID: ", id)) +
    theme_minimal()

  print(load_plot)
  ggsave(plot= load_plot, filename= "load_plot.png")
  
}
```

We hypothesized that total load would decrease later in the game because a player would be more fatigues. For most of the linemen, we don't see a decline in load throughout the game. These players either remain at a almost steady load value or increase slightly towards the end of the game. This trend could be the result of a break at halftime or a higher-intensity end to a game. 

Let's instead look at cumulative load over a game. 
```{r cum load over game plot}
game <- per_play[per_play$gameId == 2022090800,]

# select 10 defensive linemen at random
set.seed(456)
ran_nflIds <- sample(game$nflId, 10)

for (id in ran_nflIds) {
  player_plot <- game %>% filter(nflId == id)
  c_load_plot <- ggplot(player_plot, aes(x = playId, y = cum_load)) +
    geom_smooth(method = "loess", color = "blue") + 
    labs(x = "Play ID", y = "Cumulative Load", title = paste0("Player Cum. Load in Game - NFL ID: ", id)) +
    theme_minimal()

  print(c_load_plot)
  ggsave(plot = c_load_plot, filename = "c_load_plot.png")
}
```

In addition to calculating total load using the sum of accelerations, we can also look at the change in the fatigue analysis of a player. This measure will incorporate both player speed and acceleration during the play. A higher fatigue index indicates a more aggressive change in speed, so we would expect fatigue index to decrease as a player gets tired (throughout a game).

Fatigue Index over a Game
```{r fatigue index calc}
for (id in ran_nflIds) {
  player_plot <- game %>% filter(nflId == id) %>% filter(frameType != "BEFORE_SNAP") %>% mutate(fatigueIndex = a/s) %>% filter(is.numeric(fatigueIndex) & !(fatigueIndex == Inf)) %>% mutate(avgFI = mean(fatigueIndex)) %>% group_by(playId) %>% mutate(maxFI = max(fatigueIndex), countFI =sum(fatigueIndex >= avgFI)) %>% #countFI is a count per play that the fatigue index is over the average fatigue index per the game
    select(playId, countFI, maxFI) %>% distinct()
  load_plot <- ggplot(player_plot, aes(x = playId, y = maxFI)) +
    geom_point() + 
    geom_smooth(method = "loess", color = "blue") + 
    labs(x = "Play ID", y = "Max FI Per Play", title = paste0("Player Fatigue Resistance Index in Game - NFL ID: ", id)) +
    theme_minimal()

  print(load_plot)
  ggsave(plot = load_plot, "load_plot.png")
}
```
There is some variation across players regarding their change in max fatigue index. Whilst some do go down as the game goes on, there are others that stay level or even increase towards the end of the game.

It is worth noting this is just one game and a random sample of players so it is very individualized. Once we generalize the data across all games and all players, we would hope to see more of a trend.



Player height and weight may also have a relationship with acceleration. Let's visualize this relationship.

Effect of Demographics on Median Acceleration
```{r demographics}
max_acc <- data %>% group_by(nflId) %>% mutate(max_acc = mean(a)) %>% select(nflId, max_acc) %>% distinct()
demographic <- max_acc %>% inner_join(def_line_players)
demographic$birthDate <- as.Date(demographic$birthDate)


# Function to convert feet-inches to centimeters 
convert_to_cm <- function(height)
  { height_parts <- strsplit(height, "-")[[1]] 
  feet <- as.numeric(height_parts[1]) 
  inches <- as.numeric(height_parts[2]) 
  total_inches <- feet * 12 + inches 
  total_cm <- total_inches * 2.54 
  return(total_cm) } # Apply the conversion to the height column 

demographic$height <- sapply(demographic$height, convert_to_cm)

demographic <- demographic %>% na.omit() %>% mutate(age = as.integer(round(as.Date(now()) - birthDate)/365))

# Scatter plot for age vs x
plot_age <- ggplot(demographic, aes(x = age, y = max_acc)) +
  geom_point() +
  labs(title = "Age vs Acceleration", x = "Age", y = "Avg Acceleration") +
  theme_minimal() +geom_smooth()

# Scatter plot for height vs x
plot_height <- ggplot(demographic, aes(x = height, y = max_acc)) +
  geom_point() +
  labs(title = "Height vs Acceleration", x = "Height", y = "Avg Acceleration") +
  theme_minimal() +geom_smooth()

# Scatter plot for weight vs x
plot_weight <- ggplot(demographic, aes(x = weight, y = max_acc)) +
  geom_point() +
  labs(title = "Weight vs Acceleration", x = "Weight", y = "Avg Acceleration") +
  theme_minimal() +geom_smooth()
ggsave(plot= plot_age, filename = "plot_age.png")
ggsave(plot=plot_height, filename = "plot_height.png")
ggsave(plot=plot_weight, filename = "plot_weight.png")

grid.arrange(plot_age, plot_height, plot_weight, nrow = 1)

```

As one of the points of our analysis is to look for key factors that affect fatigue-resistant, we plotted the relationship between age, height and weight and median acceleration. As acceleration will be included in our derivation for "fatigue", we thought it would be interesting to see these relationships.

We would have thought as players get older and larger that acceleration decreases. However this was not the case, with only weight showing a marginally negative correlation. This probably means that other factors such as match-up and time played/time since last TO are more important factors.

With our fatigue analysis, we will also be looking at the outcome of the play. We have divided penalties into two main categories: tackle penalties (which happen during the play) and formation penalties (which happen before the play).
```{r penalties}
tackle_pen <- c("Horse Collar Tackle", "Defensive Holding", "Low Block", "Illegal Use of Hands", "Roughing the Passer", "Face Mask")
formation_pen <-  c("Illegal Shift", "Illegal Formation", "Defensive Offside")
```


Penalties Throughout a Game
```{r Tackles over Time}
play_details <- read.csv("plays.csv") %>% select(gameId, playId, quarter, gameClock)
head(play_details)

# penalties <- play %>% select(gameId, playId, nflId, penaltyNames) %>% full_join(play_details) %>% mutate(penaltyType = ifelse(penaltyNames %in% tackle_pen, "Tackle", ifelse(penaltyNames %in% formation_pen, "Formation", NA)), totalClock = (quarter-1) *  ms("15:00") +(ms("15:00")- ms(gameClock))) 


penalties <- play %>% select(gameId, playId, nflId, penaltyNames) %>% full_join(play_details) %>% mutate(penaltyType = ifelse(penaltyNames %in% tackle_pen, "Tackle", ifelse(penaltyNames %in% formation_pen, "Formation", NA)))
                                                                                                         
plot_data <- penalties %>% select(quarter, penaltyType) %>% na.omit() %>% group_by(quarter, penaltyType) %>% summarise(count = n()) %>% ungroup() 

stacked_bar <- ggplot(plot_data, aes(x = as.factor(quarter), y = count, fill = penaltyType)) +
  geom_bar(stat = "identity") +
  labs(title = "Penalties by Category and Quarter", x = "Quarter", y = "Count", fill = "Penalty Type") +
  theme_minimal()

stacked_bar
ggsave(plot=stacked_bar, filename = "stacked_bar.png")

# plot_data <- plot_data %>% na.omit()
# plot_data <- plot_data %>% pivot_wider(names_from = penaltyType, values_from = count, values_fill = list(count = 0))
# 
# plot_data <- penalties %>% select(gameId, playId, penaltyType) %>% distinct() %>% arrange(gameId)
# unique(plot_data$playId)
# 
# ggplot(data = plot_data) + geom_density(aes(x = totalClock, y = count, color = penaltyType))
# tail(penalties)
# unique(penalties$totalClock)
# ms("15:00")- ms(penalties$gameClock)

```

This doesn't show exactly what we thought. There is an increase in both types of penalties from the first to the second quarter, and an increase in formation penalties from the third to fourth quarter. We would expect some type of reset after half time, so we will also look at fatigue by quarter. This is just a plot for week 1 data so it's not totally representative of the season or the "NFL" in general.

#### Clustering Analysis
##### Part 1

We are going to cluster players based on their:
  - cumulative load
  - fatigueIndex
  - height
  - weight
  - age
  - max. acceleration

```{r grouping}
# for each gameId, playId, nflId group: if any of the penalties match a value in tackle or formation penalties, set this value to 1
total_penalties <- function(penaltyNames, tackle_pen, formation_pen) {
  tacklePenalty = ifelse(any(penaltyNames %in% tackle_pen), 1, 0)
  formationPenalty = ifelse(any(penaltyNames %in% formation_pen), 1, 0)
  return(c(tacklePenalty, formationPenalty))
}

grouped <- data %>%
  group_by(gameId, playId, nflId) %>%
  mutate(FI = a/s) %>%
  filter(is.numeric(FI) & !(FI == Inf)) %>% #takes out any rows that will mess with avg and max FI calculations
  filter(FI <= mean(FI) + sd(FI)*2 & FI >= mean(FI) - sd(FI)*2) %>%
  mutate(
    penalty_values = list(total_penalties(penaltyNames, tackle_pen, formation_pen)),
    tackle_pen = penalty_values[[1]][1], 
    formation_pen = penalty_values[[1]][2],
    avg_fatigueIndex = sum(mean(a)/mean(s)),
    max_fatigueIndex = max(FI)) %>%
  select(gameId, playId, nflId, displayName, frameId, load, max_acc, penalty_values, tackle_pen, formation_pen, avg_fatigueIndex, max_fatigueIndex, FI)

changeFI <-  grouped  %>% group_by(nflId, gameId) %>% arrange(playId) %>% summarize(change_FI = first(max_fatigueIndex) - last(max_fatigueIndex))

grouped <- inner_join(grouped, changeFI, by = c("nflId", "gameId"))
# summary(grouped$FI)
# summary(grouped$avg_fatigueIndex)
# summary(grouped$max_fatigueIndex)
# head(grouped)
# 
# sd(grouped$FI)
# grouped$penalty_values
  
```

Some values of average/max fatigue index are Infinite because the player's logged speed is 0. Let's impute 0 for those values.
```{r}
grouped$avg_fatigueIndex[is.infinite(grouped$avg_fatigueIndex)] <- 0
grouped$max_fatigueIndex[is.infinite(grouped$change_FI)] <- 0
saveRDS(grouped, "grouped.RData")
```


```{r, eval=FALSE}
# check
grouped %>%
  filter(tackle_pen == 1 | formation_pen == 1)
```

We need to add cumulative load and fatigueIndex to this dataset, making it on a per-play level.
```{r per play data}
test <- grouped %>%
  select(gameId, playId, nflId, load, displayName, max_acc, tackle_pen, formation_pen, max_fatigueIndex,  avg_fatigueIndex, change_FI) %>%
  distinct() %>%
  arrange(gameId, nflId, playId)

test <- test %>%
  group_by(gameId, nflId) %>%
  mutate(cum_load = cumsum(load))

head(test)
#summary(grouped)
```

We also need to add player height, weight, and age.
```{r add demographics}
test <- test %>%
  left_join(player_data[, c("nflId", "height", "weight", "birthDate")], by = "nflId")
```

Now that we have a dataset with the necessary values for our clustering, we need to clean the height and birthDate columns. We will change height to an numeric inches value and birthDate to a numerical age.
```{r functions}
# height conversion
class(test$height)
convert_to_inches <- function(height_str) {
  parts <- strsplit(height_str, "-")[[1]]
  feet <- as.numeric(parts[1])
  inches <- as.numeric(parts[2])
  total_inches <- (feet * 12) + inches
  return(total_inches)
}
test$height <- sapply(test$height, convert_to_inches)

# birthDate conversion
class(test$birthDate)
convert_to_age <- function(birthdate) {
  birthdate <- as.Date(birthdate, format = "%Y-%m-%d")
  date <- Sys.Date()
  age <- as.numeric(difftime(Sys.Date(), birthdate, units = "weeks")) / 52.25
  return(floor(age))
}
test$age <- convert_to_age(test$birthDate)

saveRDS(test, "test.RData")

```

We want to analyze only players that occur many times in the dataset. We will eliminate players that only have a few total entries in the dataset, as these are not the starting players.
```{r top players}
players_top <- test %>% ungroup() %>% select(displayName) %>%
  group_by(displayName) %>% mutate(count = n()) %>% distinct()
nrow(players_top)
rows50 = floor(nrow(players_top) *0.50)
#players_top <- players_top %>% filter(count >= 100)
players_top <- players_top %>% arrange(desc(count)) #do by % instead so when whole data set
players_top <- players_top[1:rows50,]
```

By selecting players with over 100 instances in the dataset, we have cut our dataset by over 50%. Selecting only these players will eliminate outliers - instances in which a player had only a few movements in a game.

Select Columns to Cluster.
```{r select cols}
clustering_columns <- c("max_acc", "change_FI", "cum_load", "height", "weight", "age")
```


Our dataframe for clustering with include one row per player in our dataset and include 12 metrics.
```{r make df}
players <- unique(players_top$displayName)

res <- as.data.frame(matrix(NA, nrow = length(players), ncol = 6))

for(i in 1:length(players)){
  temp <- test[which(test$displayName == players[i]), ]
  
  res[i, 1:6] <- colMeans(temp[, clustering_columns], na.rm = TRUE) #average of all columns above
 
}

names(res) <- c("avg_max_acc", "avg_change_fatigueIndex","avg_cum_load", "height", "weight", "age")

rownames(res) <- players
summary(res)
```

Remove NA values (before scaling).
All of our NA values are present in the 'age' column of our dataset. We will do so MICE imputation with the method Predictive Mean Matching ("PMM").
```{r impute values}
sum(is.na(res))
sum(is.na(res$age))

# imputed_data <- mice(res, m = 5, method = 'pmm', maxit = 50, seed = 500)
# impute_data <- complete(imputed_data, action = 1)

impute_mean <- function(x) {
  x[is.na(x)] <- mean(x, na.rm = TRUE) 
return(x) } # Apply the function to the dataframe 
impute_data <- data.frame(lapply(res, impute_mean))
sum(is.na(impute_data))
```

Scale clustering data.
```{r scale}
# avg_fatigueIndex is already in [0,1], so it does not need to be scaled.
#unscaled_col <- impute_data$avg_change_fatigueIndex

#all_data <- impute_data[, !names(impute_data) %in% c("avg_change_fatigueIndex")]

# Before scaling data, log transform.
all_data <- impute_data
all_data$avg_change_fatigueIndex <- log(abs(impute_data$avg_change_fatigueIndex) +1)* sign(impute_data$avg_change_fatigueIndex) #log separately because negative values

all_data[,-2] <- log(impute_data[,-2] + 1) 
 
 sdata <- scale(all_data)

#sdata <- cbind(sdata, avg_change_fatigueIndex = unscaled_col)
saveRDS(sdata, "scaled.RData")


```

Find the optimal number of clusters for analysis.
```{r optimal clusters}
gapData <- clusGap(sdata, FUNcluster = kmeans, K.max = 15)


gap_data <- data.frame( k = 1:15, gap = gapData$Tab[,"gap"], SE.sim = gapData$Tab[,"SE.sim"] )

plot_gap <- ggplot(gap_data, aes(x = k, y = gap)) + geom_line() + geom_point() + geom_errorbar(aes(ymin = gap - SE.sim, ymax = gap + SE.sim), width = 0.2) + labs(title = "Gap Statistic", x = "Number of Clusters", y = "Gap Value") + theme_minimal()

plot_gap
#fviz_gap_stat(gapData)- doesnt like package in ssh
saveRDS(plot_gap, "gapData.RData")
```

Here, we see that the optimal number of clusters is three so we will continue with three clusters to further see disparity between them.

Let's now run k-means clustering on the data.
```{r k means}
set.seed(12345) 

fit <- kmeans(x = sdata,
                centers = 4, 
                nstart = 25, 
                iter.max = 100)
clusters <- fit$cluster
centers <- fit$centers
summary(as.factor(clusters))

saveRDS(fit, "clusterModel.RData")


```

Let's move forward with three clusters.
```{r centers}
cluster <- c(1:4)
center_df <- data.frame(cluster, centers)

center_reshape <- gather(center_df, features, values, -cluster)
saveRDS(center_reshape, "heatmap1.RData")
```


Heatmap
```{r heatmap}
heatmap <- ggplot(data = center_reshape, 
                   aes(x = features, y = cluster, fill = values)) + 
  scale_y_continuous(breaks = seq(1, 8, by = 1)) + 
  geom_tile() + 
  coord_equal() + 
  theme_bw() + 
  scale_fill_gradient2(low = "blue", 
                       mid = "white", 
                       high = "red",
                       midpoint =0, 
                       space = "Lab", 
                       na.value ="grey", 
                       guide = "colourbar", 
                       aesthetics = "fill") + 
  coord_flip() 

heatmap
ggsave(plot=heatmap, filename = "heatmap.png")
```

Now, we can add total penalties to the clusters.

First, let's assign cluster number to player name.
```{r player clusters}
player_clusts <- data.frame(player_name = players, cluster = clusters)
rownames(player_clusts) <- NULL
saveRDS(player_clusts, "player_clusts.RData")

```

```{r add penalties}
# sum_pen <- as.data.frame(matrix(NA, nrow = nrow(player_clusts), ncol = 2))
# 
# for(i in 1:nrow(player_clusts)){
#   temp <- test[which(test$displayName == player_clusts$player_name[i]), ]
#   
#   sum_pen[i, 1] <- sum(temp$tackle_pen, na.rm = TRUE)
#   sum_pen[i, 2] <- sum(temp$formation_pen, na.rm = TRUE)
# }
# 
# colnames(sum_pen) <- c("total_tackle_pen", "total_formation_pen")
# sum_pen <- cbind(player_clusts, sum_pen)
names_penalties <- test %>% group_by(displayName) %>% summarise( avg_formation = mean(formation_pen), avg_tackle = mean(tackle_pen), avg_pen = mean(tackle_pen+formation_pen)) %>% inner_join(player_clusts, by = c("displayName" = "player_name"))


penalties_perGame <- test %>% group_by(displayName, gameId) %>% summarise( avg_formation = mean(formation_pen), avg_tackle = mean(tackle_pen)) %>% inner_join(player_clusts, by = c("displayName" = "player_name")) %>% ungroup() %>% select(-gameId, -displayName) %>% group_by(cluster) %>% summarise(avg_formation_perGame = mean(avg_formation), avg_tackle_perGame = mean(avg_tackle)) %>% gather( key="features", value="values", -cluster) #pivot longer 
penalties_perGame$values = scale(penalties_perGame$values )
```

Now that we have a sum of penalties for each player, we can count this total for each cluster and add it to our heatmap.
```{r calc totals}
# totals <- as.data.frame(matrix(NA, nrow = 3, ncol = 4))
# 
# for(i in 1:3){
#   temp <- sum_pen[which(sum_pen$cluster == i), ]
#   
#   totals[i, 1] <- sum(temp$total_tackle_pen, na.rm = TRUE)
#   totals[i, 2] <- sum(temp$total_formation_pen, na.rm = TRUE)
#   totals[i, 3] <- sum(temp$total_tackle_pen, na.rm = TRUE)/nrow(temp)
#   totals[i, 4] <- sum(temp$total_formation_pen, na.rm = TRUE)/nrow(temp)
# }
# 
# colnames(totals) <- c("total_tackle_pen", "total_formation_pen", "tackle_pen_percent",
#                       "formation_pen_percent")
```

Let's add these penalty calculations back to our cluster dataframe and create a new heatmap.
```{r new scaling}
# totals_scaled <- scale(totals)
# new_center_df <- cbind(center_df, totals_scaled)
# 
# new_center_reshape <- gather(new_center_df, features, values, avg_max_acc:formation_pen_percent)

new_center_reshape <- gather(center_df, features, values,-cluster) %>% rbind(penalties_perGame)
saveRDS(new_center_reshape, "heatmap2.RData")

```

```{r new heatmap}
heatmap2 <- ggplot(data = new_center_reshape, 
                   aes(x = features, y = cluster, fill = values)) + 
  scale_y_continuous(breaks = seq(1, 8, by = 1)) + 
  geom_tile() + 
  coord_equal() + 
  theme_bw() + 
  scale_fill_gradient2(low = "blue", 
                       mid = "white", 
                       high = "red",
                       midpoint =0, 
                       space = "Lab", 
                       na.value ="grey", 
                       guide = "colourbar", 
                       aesthetics = "fill") + 
  coord_flip() 

heatmap2
ggsave(plot=heatmap2, filename = "heatmap2.png")
```
From this clustering analysis, we see some patterns in terms of penalties.

 - Cluster 3 has the highest amount/percentage of tackling penalties and the lowest percentage of formation penalties. These players have the lowest weight, age, and height, with mid-range values for load and acceleration.
 - Cluster 2 has low penalties (in terms of total count and percentage) for both categories. These individuals have low values for load and acceleration. These individuals have the highest weight and height.
 - Cluster 1 has the highest values for formation penalties. These individuals have low weight but are in the upper 50% for age and height, as well as acceleration. 
 
In terms of fatigue, we see average fatigue index being inversely proportional to weight and height. We see a greater acceleration for players with lower height and weight - these players are able to gain speed quicker than other players, but may also get fatigued quicker.


##### Part 2
Now let's see the influence of these similar "fatigue" and "demographic" variables on positive defensive performance, rather than negative penalties.


The positive values we will look at:
 - forcedFumbleAsDefense: forced a fumble by the opposing team
 - halfSackYardsAsDefense: yards conceded by the offense because of a half-sack
 - passDefensed: a passing play was stopped by the player
 - quarterbackHit: player recorded a QB hit
 - sackYardsAsDefense: yards conceded by the offense because of a sack by the player
 - soloTackle: player recorded a solo tackle on this play
 - tackleAssist: player was awarded an assisted tackle
 - tackleForALoss: player recorded a tackle behind the line of scrimmage
 - tackleForALossYardage: yards conceded by the offense because of a tackle
 
 
```{r}
positive_defense <- data %>% group_by(nflId) %>%
  select(gameId, playId, nflId, forcedFumbleAsDefense, passDefensed, quarterbackHit, soloTackle, tackleAssist, tackleForALoss) %>% group_by(gameId, playId, nflId) %>% summarise(across(everything(), ~ as.integer(any(. == 1))))

counts_4weeks <- positive_defense %>% ungroup()%>% select(-c(gameId, playId, nflId)) %>% summarise_all(sum)


#Number of each occurence over the weeks
counts_4weeks

positive_defense_yds <- data %>% group_by(nflId) %>%
  select(gameId, playId, nflId, halfSackYardsAsDefense, sackYardsAsDefense, tackleForALossYardage) %>% group_by(gameId, playId, nflId) %>% summarise(across(everything(), ~ as.integer(any(. == 1))))

counts_yds_4weeks <- positive_defense_yds %>% ungroup()%>% select(-c(gameId, playId, nflId)) %>% summarise_all(mean)
counts_yds_4weeks


#Shows there is very little recorded in terms of yardage lost because of d-line. We are better off using the binary values
counts_yds_4weeks


positive_defense <- positive_defense %>% ungroup() %>% inner_join(player_data %>% select(nflId, displayName))
summary_def <- positive_defense %>% select(-playId) %>% group_by(displayName) %>% summarise_all(mean) #avg per player per game num of each def

new_col_names <- names(summary_def)
new_col_names[4:9] <- paste0(new_col_names[4:9], "_AvgPerGame") 
summary_def <- setNames(summary_def, new_col_names)

summary_def <- summary_def %>% select(-gameId, -nflId)
scaled_count <- data.frame(cbind(displayName = players_top$displayName,  scale(players_top$count))) %>% inner_join(player_clusts, by = c("displayName" =  "player_name")) %>% rename(play_count = V2) %>% mutate(play_count =as.numeric(play_count))



play_counts <- inner_join(players_top, player_clusts, by = c("displayName" =  "player_name")) %>% rename(plays_count = count)

#player_clust < summary_def as it is filtered to just top players
player_clust_def <- right_join(summary_def, play_counts, by = c("displayName")) %>% na.omit()


clustered_def <- player_clust_def %>% group_by(cluster) %>% select(-displayName) %>% summarise_all(mean) #summarise avg of players in cluster

scaled <- data.frame(scale(clustered_def %>% select(-cluster))) %>% cbind(cluster = c(1,2,3,4)) #scaling

new_clustered_def <- inner_join(scaled, center_df, by = "cluster") #joining with clustered "fatigue stats"

new_clustered_def <- new_clustered_def %>% gather( key="features", value="values", -cluster) #pivot longer 
saveRDS(new_clustered_def, "heatmap3.RData")

```

```{r}
heatmap3 <- ggplot(data = new_clustered_def, 
                   aes(x = features, y = cluster, fill = values)) + 
  scale_y_continuous(breaks = seq(1, 8, by = 1)) + 
  geom_tile() + 
  coord_equal() + 
  theme_bw() + 
  scale_fill_gradient2(low = "blue", 
                       mid = "white", 
                       high = "red",
                       midpoint =0, 
                       space = "Lab", 
                       na.value ="grey", 
                       guide = "colourbar", 
                       aesthetics = "fill") + 
  coord_flip() 

heatmap3
ggsave(plot=heatmap3, filename = "heatmap3.png")
```
Cluster Analysis

Group 1: Defensive Impact Plays
These stats reflect high-impact plays that significantly disrupt the offense or stop their progress forcefully.

forcedFumbleAsDefense

quarterbackHit

soloTackle

tackleForALoss


Group 2: Supportive Defensive Plays
These stats highlight plays where the defender provides crucial support, either by assisting or directly preventing a successful offensive move.

passDefensed

tackleAssist

Looking at both our heat maps, we need to decide which "fatigue" features to keep. Those will be:
- age
- avg_cum_load
- height
- max_fatigueIndex (avg per player, per game of max FI)
- weight
- *_AvgPerGame
- avg_max_acc (avg per player, per game of max acc)
- plays_count (number of plays)



### Clusters by Player


```{r}
plot1 <- res %>% select(avg_change_fatigueIndex, avg_cum_load) 
plot1$player_name <- rownames(plot1)
plot1 <- inner_join(plot1, player_clusts)
plot1$cluster <- as.factor(plot1$cluster)

saveRDS(plot1, "playerplot1.RData")


g_1 <- ggplot(plot1, # Set dataset
              aes(x = avg_change_fatigueIndex,  # Set x-axis as number of fastballs
                  y = avg_cum_load, color = cluster)) + # Set y-axis as fastball speed
  geom_point() + # Add geom point for scatter plot
  # Label players with fastball speed above 95
  geom_text_repel(data = plot1,
                  aes(label = paste(player_name))) +
   theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid
  labs(x = "Avg Change Fatigue Resistance Index", y = "Avg Cumulative Load",
       title = "Defensive Line by Cluster- Fatigue Resistance",
       subtitle = "NFL 2022")
g_1
ggsave(plot= g_1, filename= "g_1.png")
```
```{r}
plot2 <- inner_join(summary_def, names_penalties) %>% mutate(cluster = as.factor(cluster)) %>% mutate(composite_pos = rowSums(select(., 2:7)))

saveRDS(plot2, "playerplot2.RData")
g_2 <- ggplot(plot2, # Set dataset
              aes(x = composite_pos,  # Set x-axis as number of fastballs
                  y = avg_pen, color = cluster)) + # Set y-axis as fastball speed
  geom_point() + # Add geom point for scatter plot
  # Label players with fastball speed above 95
  geom_text_repel(data = plot2,
                  aes(label = paste(displayName))) +
   theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid
  labs(x = "Composite Positive Defensive Metric Per Game", y = "Avg Total Penalties per Game",
       title = "Defensive Line by Cluster- Tackles vs Penalties",
       subtitle = "NFL 2022")
g_2
ggsave(plot= g_2, filename= "g_2.png")
```
### Free Agent Selection
```{r curr free agents}
page = read_html("https://www.spotrac.com/nfl/free-agents/_/year/2024/status/available/sort/contract_value")
free_tbl <- data.frame(html_table(page)[[1]] )
names(free_tbl)[1] <- "displayName"

free_tbl <- free_tbl %>% filter(displayName %in% unique(test$displayName))
free_tbl <- free_tbl %>% filter(displayName %in% unique(players_top$displayName))


plot3 <- inner_join(plot1 %>% select(-cluster), plot2, by = c("player_name" = "displayName"))%>% filter(player_name %in% free_tbl$displayName) %>% mutate(composite = rowSums(select(., 4:12)))
 
g_3 <- ggplot(plot3, # Set dataset
              aes(x = avg_change_fatigueIndex,  # Set x-axis as number of fastballs
                  y = avg_cum_load, color = cluster, size = composite, alpha = 0.7)) + # Set y-axis as fastball speed
  geom_point() + # Add geom point for scatter plot
  geom_text_repel(data = plot3,
                  aes(label = paste(player_name))) +
   theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid
  labs(x = "Avg Change Fatigue Resistance Index", y = "Avg Cumulative Load",
       title = "Defensive Line by Cluster- Fatigue Resistance",
       subtitle = "NFL 2022")+ guides(alpha = "none")
g_3

g_4 <- ggplot(plot3, # Set dataset
              aes(x = avg_change_fatigueIndex,  # Set x-axis as number of fastballs
                  y = avg_cum_load, color = cluster, size = avg_pen, alpha = 0.7)) + # Set y-axis as fastball speed
  geom_point() + # Add geom point for scatter plot
  geom_text_repel(data = plot3,
                  aes(label = paste(player_name))) +
   theme(panel.grid.major = element_blank(), # Remove grid
        panel.grid.minor = element_blank(), # Remove grid
        panel.border = element_blank(), # Remove grid
        panel.background = element_blank()) + # Remove grid
  labs(x = "Avg Change Fatigue Resistance Index", y = "Avg Cumulative Load",
       title = "Defensive Line by Cluster- Fatigue Resistance",
       subtitle = "NFL 2022")+ guides(alpha = "none")
g_4
```




